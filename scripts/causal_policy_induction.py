# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Policy Induction Engine (Safety Discovery)

This script implements the "Safety Discovery" loop. It treats the trained SCM
as a simulator to find hazardous boundaries where an action (e.g., Blocking)
causes unacceptable downstream risk (e.g., Churn), and converts these findings
into deterministic OPA Rego policies.
"""

import logging
import datetime
import numpy as np
from src.causal.engine import ProductionSCM

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("PolicyInduction")

OUTPUT_FILE = "policies/generated_causal_rules.rego"
RISK_THRESHOLD = 0.45

def discover_safety_boundaries():
    engine = ProductionSCM()
    if not engine._model:
        logger.error("SCM not loaded. Aborting induction.")
        return

    logger.info("ðŸ” Starting Safety Discovery Loop...")

    # Define Search Space
    # We investigate the relationship between Tenure and Churn under "BLOCK" intervention
    tenure_range = np.linspace(0, 10, 21) # 0, 0.5, 1.0 ... 10.0

    unsafe_threshold = None

    logger.info(f"Target Risk Metric: Churn_Probability > {RISK_THRESHOLD}")
    logger.info("Simulating Intervention: Customer_Friction = 0.9 (BLOCK)")

    for tenure in tenure_range:
        # Context: A user with this tenure, average amount, average risk
        # Note: In a real search, we would vary other parameters too or marginalize them.
        # Here we fix average values to isolate Tenure effect.
        context = {
            "Tenure_Years": tenure,
            "Transaction_Amount": 1000,
            "Location_Mismatch": 0,
            "Fraud_Risk": 0.5 # Ambiguous risk
        }

        intervention = {"Customer_Friction": 0.9}

        churn_risk = engine.simulate_intervention(
            context=context,
            intervention=intervention,
            target_variable="Churn_Probability"
        )

        logger.info(f"  [Tenure={tenure:.1f}y] -> Churn Risk: {churn_risk:.4f}")

        if churn_risk > RISK_THRESHOLD:
            if unsafe_threshold is None:
                unsafe_threshold = tenure
                logger.warning(f"ðŸš¨ HAZARD DETECTED at Tenure >= {tenure}y (Risk: {churn_risk:.4f})")
                break # Found the boundary (assuming monotonicity for simplicity)

    if unsafe_threshold:
        generate_rego_policy(unsafe_threshold)
    else:
        logger.info("âœ… No hazards detected within search space.")

def generate_rego_policy(tenure_limit: float):
    logger.info(f"ðŸ“ Generating Rego Policy for Tenure >= {tenure_limit}...")

    timestamp = datetime.datetime.now().isoformat()

    rego_content = f"""package financial_advisor.safety.generated

# AUTOMATICALLY GENERATED BY CAUSAL POLICY INDUCTION
# Source: scripts/causal_policy_induction.py
# Timestamp: {timestamp}
#
# Rationale: Causal simulation indicates that blocking users with
# Tenure >= {tenure_limit} years leads to Churn Probability > {RISK_THRESHOLD}.

default allow = true

# Deny BLOCK action if Tenure is high (The "Insult Effect")
deny_block_high_tenure if {{
    input.action == "block_transaction"
    input.user.tenure_years >= {tenure_limit}
    msg := "Safety Constraint: Blocking high-tenure user causes unacceptable churn risk."
}}
"""

    with open(OUTPUT_FILE, "w") as f:
        f.write(rego_content)

    logger.info(f"âœ… Policy written to {OUTPUT_FILE}")

if __name__ == "__main__":
    discover_safety_boundaries()
