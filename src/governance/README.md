# Governance Logic (Layer 3: Enforcement & Bridge)

This directory contains the "Symbolic Control" layer that bridges Policy to Code and enforces Safety in Real-Time.

## Architecture II: In-Process Wasm
We have migrated from an HTTP Sidecar model (Architecture I) to an In-Process Wasm model (Architecture II).
*   **Performance:** Checks run in <1ms (function call) vs 20ms+ (HTTP).
*   **Security:** Rely on Cloud Run's gVisor for isolation.

## Components

### 1. Policy Engine (`engine.py`)
**Role:** In-Process Governance execution.
*   **Library:** `opa-wasm` (Python bindings for OPA WebAssembly).
*   **Input:** Compiled `policy.wasm` file.
*   **Process:** Loads Wasm into RAM at startup. Executes `policy.evaluate(input_json)`.

### 2. The Transpiler (`transpiler.py`)
**Role:** Automated Rule Derivation (Phase 3).
*   **Input:** Structured `ProposedUCA` objects from the Risk Analyst.
*   **Process:** Parses `constraint_logic` (variable, operator, threshold).
*   **Output:** Generates Python code strings for NeMo actions.
*   **Supported Logic:**
    *   `check_slippage_risk` (Volume based)
    *   `check_drawdown_limit` (Portfolio based)
    *   `check_data_latency` (Temporal)
    *   `check_atomic_execution` (State based)

### 3. NeMo Actions (`nemo_actions.py`)
**Role:** Real-Time Enforcement (Phase 4).
These functions are called by NeMo Guardrails during the "Hot Path" of execution. They implement a **Hybrid Policy** model:

*   **Static Mechanism (CBF):** Critical safety checks like **Drawdown Limit** are hardcoded as **Control Barrier Functions** ($h(x) = Limit - Value$). This ensures mathematical rigor and prevents AI hallucinations from altering the safety logic itself.
*   **Dynamic Policy (Configuration):** While the *logic* is static, the *parameters* (e.g., the specific drawdown limit) are read dynamically from `safety_params.json`.
*   **Characteristics:**
    *   **Deterministic:** No LLM calls. Execution < 10ms.
    *   **State Aware:** Checks `audit_trail` for multi-leg trade integrity.
    *   **Input Sanitization:** Strictly validates dynamic configuration (e.g., 0.0 < limit < 1.0) and falls back to safe defaults (5%) on error.

### 4. Build Process (Production)
To run in production, the `policy.wasm` file is a **hard requirement**. The application will crash at startup if it is missing.

**Step 1: Install OPA CLI**
Ensure you have the `opa` CLI tool installed.

**Step 2: Compile Policy**
Run the following command from the repository root to compile your Rego policies into a Wasm bundle:
```bash
opa build -t wasm -e finance/allow policies/ -o policy.wasm
```

**Step 3: Deploy**
Ensure the generated `policy.wasm` file is copied into the Docker image or mounted at `/app/policy.wasm`.
*   **Docker:** Add `COPY policy.wasm /app/policy.wasm` to your `Dockerfile`.
*   **Cloud Run:** The `deployment/service.yaml` expects the file at `/app/policy.wasm` (via `OPA_WASM_PATH`).

### 5. Safety Parameters (`safety_params.json`)
A JSON configuration file generated by the offline Risk Analyst.
*   **Role:** Separation of Policy (Value) from Mechanism (Code).
*   **Update Mechanism:** Updated atomically via `os.replace` by `scripts/offline_risk_update.py`.
*   **Content:** Contains key safety thresholds like `drawdown_limit`.
