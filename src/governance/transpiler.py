import logging
from typing import List, Dict, Any
from src.agents.risk_analyst.agent import ProposedUCA

logger = logging.getLogger("Governance.Transpiler")

class PolicyTranspiler:
    """
    Automated Rule Derivation (Phase 3).
    Converts Risk Analyst UCAs (with Structured Logic) into NeMo-compatible Python Actions.
    """

    def generate_nemo_action(self, uca: ProposedUCA) -> str:
        """
        Transpiles a single UCA into a Python function string using the `constraint_logic`.
        """
        logger.info(f"Transpiling UCA: {uca.description}")
        logic = uca.constraint_logic

        # 1. Slippage / Volume Check
        if logic.variable == "order_size" or "volume" in logic.threshold:
            threshold_multiplier = logic.threshold.split("*")[0].strip() # Extract '0.01' from '0.01 * daily_volume'
            if not threshold_multiplier.replace('.', '', 1).isdigit():
                threshold_multiplier = "0.01" # Fallback

            return f"""
def check_slippage_risk(context: Dict[str, Any] = {{}}, event: Dict[str, Any] = {{}}) -> bool:
    '''
    Enforces {uca.hazard}: Blocks market orders exceeding {threshold_multiplier} of daily volume.
    Condition: {logic.condition}
    '''
    order_type = context.get("order_type", "MARKET")
    order_size = float(context.get("order_size", 0))
    daily_vol = float(context.get("daily_volume", 1000000))

    if order_type == "MARKET" and order_size > (daily_vol * {threshold_multiplier}):
        # UCA Detected: {uca.category}
        return False

    return True
"""

        # 2. Latency Check
        if logic.variable == "latency":
            limit = logic.threshold
            return f"""
def check_data_latency(context: Dict[str, Any] = {{}}, event: Dict[str, Any] = {{}}) -> bool:
    '''
    Enforces {uca.hazard}: Blocks trades if data latency > {limit}ms.
    '''
    # Mock check - in prod read from context['market_data_timestamp']
    current_latency = 50 # Mock
    if current_latency > {limit}:
        return False
    return True
"""

        # 3. Drawdown Check
        if logic.variable == "drawdown":
            limit = logic.threshold
            return f"""
def check_drawdown_limit(context: Dict[str, Any] = {{}}, event: Dict[str, Any] = {{}}) -> bool:
    '''
    Enforces {uca.hazard}: Blocks buy orders if drawdown > {limit}%.
    '''
    current_drawdown = float(context.get("drawdown_pct", 0))
    if current_drawdown > {limit}:
        return False
    return True
"""

        # 4. Atomic Execution Check
        if logic.variable == "time_delta_legs":
            return f"""
def check_atomic_execution(context: Dict[str, Any] = {{}}, event: Dict[str, Any] = {{}}) -> bool:
    '''
    Enforces {uca.hazard}: Ensures multi-leg trades complete atomically.
    '''
    # Simplified mock
    legs_completed = context.get("legs_completed", 0)
    legs_required = context.get("legs_required", 2)
    if legs_completed < legs_required:
        return False # Stopped Too Soon
    return True
"""

        # Fallback
        return f"# No template found for UCA: {uca.description}"

    def transpile_policy(self, ucas: List[ProposedUCA]) -> str:
        """
        Generates the full Python module content.
        """
        code_blocks = [
            "from typing import Dict, Any",
            "",
            "# AUTOMATICALLY GENERATED BY GOVERNANCE TRANSPILER",
            ""
        ]
        for uca in ucas:
            code_blocks.append(self.generate_nemo_action(uca))
        return "\n".join(code_blocks)

# Global Instance
transpiler = PolicyTranspiler()
